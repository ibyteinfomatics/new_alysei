//
//  PostCommentsViewController.swift
//  Alysei
//
//  Created by Shivani Vohra Gandhi on 11/07/21.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import IQKeyboardManagerSwift
import AlamofireImage


protocol PostCommentsDisplayLogic: class {
    func loadComments(_ response: PostComments.Comment.Response)
}

class PostCommentsViewController: AlysieBaseViewC, PostCommentsDisplayLogic  {
    var interactor: PostCommentsBusinessLogic?
    var router: (NSObjectProtocol & PostCommentsRoutingLogic & PostCommentsDataPassing)?

    // MARK:- Object lifecycle

    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    @IBOutlet weak var lblHeading: UILabel!
    var commentmessages:[CommentClass]?
    var countLikeComment:[PostClass]?
    var commentLike:[Comment_Like_Class]?

    var postCommentsUserDataModel: PostCommentsUserData!
    var model: PostComments.Comment.Response!
    var postOwnerID: Int!
    var commentID: Int! // this is to be used when user taps on reply button.
    
    var like = 0,comment = 0 , postid = 0
    var commentId = 0
    var precommentId = 0
    var selectedcommentId = 0
    var replyTap = false

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
        
    }
    
    func receiveComment() {
        self.commentmessages?.removeAll()
        kChatharedInstance.receivce_Comment(postId: String.getString(self.postid)) { (message) in
            
            
            self.commentmessages = message
            self.commentTextfield.returnKeyType = .next
            self.receiveCommentLike()
            //self.scrollToLTopRow()
            
            if self.commentmessages?.count ?? 0 == 0{
                self.tableView.reloadData()
                self.vwBlank.isHidden = false
                self.commentTextfield.becomeFirstResponder()
            }else{
                self.vwBlank.isHidden = true
            }
            
        }
        
            
    }
    
    func receiveCommentLike() {
        
        kChatharedInstance.receivce_Comment_Like(postId: String.getString(self.postid)) { (message) in
            
            self.commentLike?.removeAll()
            self.commentLike = message
            print("sdsdd",self.commentLike?.count)
            
            for i in 0..<(self.commentmessages?.count ?? 0){
                
                for j in 0..<(self.commentLike?.count ?? 0){
                    
                    if self.commentmessages?[i].core_comment_id == self.commentLike?[j].comment_id {
                        
                        if Int.getInt(kSharedUserDefaults.loggedInUserModal.userId) == self.commentLike?[j].user_id {
                            
                            self.commentmessages?[i].isLike = true
                            
                        }
                        
                    }
                    
                    
                    for k in 0..<(self.commentmessages?[i].reply.count ?? 0){
                        
                        if self.commentmessages?[i].reply[k].core_comment_id == self.commentLike?[j].comment_id {
                            
                            if Int.getInt(kSharedUserDefaults.loggedInUserModal.userId) == self.commentLike?[j].user_id {
                                
                                self.commentmessages?[i].reply[k].isLike = true
                                
                            }
                            
                        }
                    }
                    
                    
                }
                
                self.tableView.reloadData()
            }
            
            
        }
        
            
    }
        
    

    // MARK:- Setup

    private func setup() {
        let viewController = self
        let interactor = PostCommentsInteractor()
        let presenter = PostCommentsPresenter()
        let router = PostCommentsRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }

    // MARK: Routing

    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if let scene = segue.identifier {
            let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
            if let router = router, router.responds(to: selector) {
                router.perform(selector, with: segue)
            }
        }
    }
    
    override func viewDidLayoutSubviews() {
      super.viewDidLayoutSubviews()
      self.viewNavigation.drawBottomShadow()
       // self.tableView.drawBottomShadow()
    }

    // MARK:- View lifecycle

    override func viewDidLoad() {
        super.viewDidLoad()
        lblHeading.text = AppConstants.kComments
        sendCommentButton.setTitle(AppConstants.kPost, for: .normal)
        IQKeyboardManager.shared.enable = false
        IQKeyboardManager.shared.enableAutoToolbar = false
        
        self.tableView.register(UINib(nibName: "PostCommentsCell", bundle: nil), forCellReuseIdentifier: "cell")

        self.tableView.tableFooterView = UIView()
        self.tableView.delegate = self
        self.tableView.dataSource = self
        //self.tableView.allowsSelection = false

        self.commentTextfield.delegate = self
        
        
        if postid > 0 {
            self.interactor?.fetchComments(self.postid)
        } else {
            self.interactor?.fetchComments(self.postCommentsUserDataModel.postID)
        }

        
        self.profilePhotoButton.layer.cornerRadius = self.profilePhotoButton.frame.width / 2.0
        self.profilePhotoButton.layer.masksToBounds = true
        
        let profilePhoto = kSharedUserDefaults.getProfilePic()
        
        if profilePhoto == "" || profilePhoto == nil{
           print("No Image")
        }else{
       
            let url = URL(string: kSharedUserDefaults.getProfilePic())!
            //self.profilePhotoButton.sd_setImage(with:URL(string: "Your_url"), forState:.normal)
            self.profilePhotoButton.af_setImage(for: .normal, url: url)
        }
        
        /*if let profilePhoto = LocalStorage.shared.fetchImage(kSharedUserDefaults.getProfilePic()) {
            self.profilePhotoButton.setImage(profilePhoto, for: .normal)
//
        } else {
            let profilePhoto = UIImage(named: "profile_icon")
            self.profilePhotoButton.setImage(profilePhoto, for: .normal)
            
        }*/
        
        for i in 0..<(self.commentmessages?.count ?? 0){
            self.commentmessages?[i].isSelected = false
        }
        
        tableView.contentInset = UIEdgeInsets(top: 5, left: 0, bottom: 10, right: 0)
        tableView.rowHeight = UITableView.automaticDimension
//        self.commentTextfield.becomeFirstResponder()
    }
    
    
    
    override func viewWillAppear(_ animated: Bool) {
        if postid == 0 {
           postid = self.postCommentsUserDataModel.postID
        }
        IQKeyboardManager.shared.enable = false
        //self.commentTextfield.becomeFirstResponder()
        self.tabBarController?.tabBar.isHidden = true
        NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillShow), name: UIResponder.keyboardWillShowNotification, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(keyboardWillHide), name: UIResponder.keyboardWillHideNotification, object: nil)
        bottomViewForCommentTextField.layer.borderWidth = 1
        bottomViewForCommentTextField.layer.borderColor = UIColor.lightGray.cgColor
        receiveComment()
        
    }
    
    @IBOutlet weak var commentTextfield: IQTextView!
    // MARK:- IBOutlets
    @IBOutlet weak var viewNavigation: UIView!
    //@IBOutlet weak var backButton: UIButton!
   // @IBOutlet weak var titleLabel: UILabelExtended!
    @IBOutlet weak var tableView: UITableView!

    @IBOutlet weak var bottomViewForCommentTextField: UIView!
   // @IBOutlet weak var commentTextfield: UITextFieldBorderWidthAndColor!
    @IBOutlet weak var profilePhotoButton: UIButton!
    @IBOutlet weak var sendCommentButton: UIButton!
    @IBOutlet weak var vwBlank: UIView!
    @IBOutlet var bottomViewBottmConstraint: NSLayoutConstraint!

    // MARK:- protocol methods
    func loadComments(_ response: PostComments.Comment.Response) {
        self.model = response
        self.commentTextfield.text = ""
        self.tableView.reloadData()
       // self.commentTextfield.resignFirstResponder()
//        if !self.commentTextfield.isFirstResponder {
//            self.commentTextfield.becomeFirstResponder()
//        }
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        IQKeyboardManager.shared.enable = true
        IQKeyboardManager.shared.enableAutoToolbar = true
        NotificationCenter.default.removeObserver(UIResponder.keyboardWillShowNotification)
        NotificationCenter.default.removeObserver(UIResponder.keyboardWillHideNotification)
        
        
    }

    //MARK: custom methods
    @objc func keyboardWillShow(notification: NSNotification) {
        var keyboardSize: CGSize = CGSize.zero
        if let value = notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue{
            keyboardSize = value.cgRectValue.size
            if MobileDeviceType.IS_IPHONE_X || MobileDeviceType.IS_IPHONE_X_MAX {
                bottomViewBottmConstraint.constant = keyboardSize.height-34
            }else {
                bottomViewBottmConstraint.constant = keyboardSize.height
            }
            self.view.layoutIfNeeded()
            scrollToLTopRow()
            
        }
    }
    
    @objc func keyboardWillHide(notification: NSNotification){
        bottomViewBottmConstraint.constant = 0
        self.view.layoutIfNeeded()
    }
  
    
    func scrollToLTopRow() {
        DispatchQueue.main.async {
            if Int.getInt(self.commentmessages?.count) != 0 {
                //let indexPath = IndexPath(row: Int.getInt(self.commentmessages?.count) - 1, section: 0)
                let indexPath = IndexPath(row: 0, section: 0)
                self.tableView.scrollToRow(at: indexPath, at: .top, animated: false)
                //self.commentTextfield.becomeFirstResponder()
            }
        }
    }

    func sendComment() {
        
        
        let params: [String:Any] = [
            
            "post_id": self.postid,
            "comment": self.commentTextfield.text,
            "user_id" : Int.getInt(kSharedUserDefaults.loggedInUserModal.userId)
            
        ]
        
        TANetworkManager.sharedInstance.requestApi(withServiceName: APIUrl.kPostComment, requestMethod: .POST, requestParameters: params, withProgressHUD: true) { (dictResponse, error, errorType, statusCode) in
            
            let dictResponse = dictResponse as? [String:Any]
            
            
            if let data = dictResponse?["data"] as? [String:Any]{
                
                let core_comment_id = Int.getInt(data["core_comment_id"])
                
                //print("core_comment_id ",core_comment_id)
                
                let date = Date()
                let df = DateFormatter()
                df.dateFormat = "yyyy-MM-dd HH:mm:ss"
                let dateString = df.string(from: date)
                
                let likecomment = LikeCommentClass()
                likecomment.likeCount = self.like
                likecomment.commentCount = self.comment
                likecomment.postId = self.postid
                
                let comment = CommentClass()
                comment.body = self.commentTextfield.text
                comment.core_comment_id = core_comment_id//self.postCommentsUserDataModel.postID
                comment.created_at = dateString
                comment.comment_like_count = 0
                
                let poster = PosterClass()
                
                if kSharedUserDefaults.loggedInUserModal.companyName != ""{
                    poster.restaurant_name = kSharedUserDefaults.loggedInUserModal.companyName
                } else if kSharedUserDefaults.loggedInUserModal.restaurantName != ""{
                    poster.restaurant_name = kSharedUserDefaults.loggedInUserModal.restaurantName
                } else if kSharedUserDefaults.loggedInUserModal.firstName != ""{
                    poster.restaurant_name = String.getString(kSharedUserDefaults.loggedInUserModal.firstName)+String.getString(kSharedUserDefaults.loggedInUserModal.lastName)
                }
                
                //poster.restaurant_name = ""
                poster.email = String.getString(kSharedUserDefaults.loggedInUserModal.email)
                poster.name = String.getString(kSharedUserDefaults.loggedInUserModal.userName)
                poster.role_id = Int.getInt(kSharedUserDefaults.loggedInUserModal.memberRoleId)
                poster.user_id = Int.getInt(kSharedUserDefaults.loggedInUserModal.userId)
                
                let avatar = CommentAvatarId()
                avatar.attachment_type = "jpg"
                avatar.attachment_url = kSharedUserDefaults.getProfilePic() //kSharedUserDefaults.loggedInUserModal.avatar?.imageURL?.replacingOccurrences(of: imageDomain, with: "")
                avatar.poster_created_at = dateString
                avatar.id = Int.getInt(kSharedUserDefaults.loggedInUserModal.userId)
                avatar.updated_at = dateString
                
                kChatharedInstance.send_comment(countDic: likecomment, commentDisc: comment, poster: poster, avtar: avatar, postId: String.getString(self.postid) )
                
                self.commentTextfield.text = ""
                self.commentId = 0
                self.receiveComment()
                self.commentTextfield.resignFirstResponder()
                self.tableView.reloadData()
                
            }
            
        }
        
    }
    
    func sendReplyComment(comment_id : String) {
       
        let params: [String:Any] = [
            
            "post_id": self.postid,
            "reply": self.commentTextfield.text,
            "user_id" : Int.getInt(kSharedUserDefaults.loggedInUserModal.userId),
            "comment_id":comment_id
            
        ]
        
        TANetworkManager.sharedInstance.requestApi(withServiceName: APIUrl.kPostReplyComment, requestMethod: .POST, requestParameters: params, withProgressHUD: true) { (dictResponse, error, errorType, statusCode) in
            
            let dictResponse = dictResponse as? [String:Any]
            
            
            if let data = dictResponse?["data"] as? [String:Any]{
                
                let core_comment_id = Int.getInt(data["core_comment_id"])
                
                //print("core_comment_id ",core_comment_id)
                
                let date = Date()
                let df = DateFormatter()
                df.dateFormat = "yyyy-MM-dd HH:mm:ss"
                let dateString = df.string(from: date)
                
                let likecomment = LikeCommentClass()
                likecomment.likeCount = self.like
                likecomment.commentCount = self.comment
                likecomment.postId = self.postid
                
                let comment = CommentClass()
                comment.body = self.commentTextfield.text
                comment.core_comment_id = core_comment_id//self.postCommentsUserDataModel.postID
                comment.created_at = dateString
                comment.comment_like_count = 0
                comment.previous_comment_id = Int.getInt(comment_id)
                
                let poster = PosterClass()
                
                if kSharedUserDefaults.loggedInUserModal.companyName != ""{
                    poster.restaurant_name = kSharedUserDefaults.loggedInUserModal.companyName
                } else if kSharedUserDefaults.loggedInUserModal.restaurantName != ""{
                    poster.restaurant_name = kSharedUserDefaults.loggedInUserModal.restaurantName
                } else if kSharedUserDefaults.loggedInUserModal.firstName != ""{
                    poster.restaurant_name = String.getString(kSharedUserDefaults.loggedInUserModal.firstName)+String.getString(kSharedUserDefaults.loggedInUserModal.lastName)
                }
                
                //poster.restaurant_name = ""
                poster.email = String.getString(kSharedUserDefaults.loggedInUserModal.email)
                poster.name = String.getString(kSharedUserDefaults.loggedInUserModal.userName)
                poster.role_id = Int.getInt(kSharedUserDefaults.loggedInUserModal.memberRoleId)
                poster.user_id = Int.getInt(kSharedUserDefaults.loggedInUserModal.userId)
                
                
                let avatar = CommentAvatarId()
                avatar.attachment_type = "jpg"
                avatar.attachment_url = kSharedUserDefaults.loggedInUserModal.avatar?.imageURL?.replacingOccurrences(of: imageDomain, with: "")
                avatar.poster_created_at = dateString
                avatar.id = Int.getInt(kSharedUserDefaults.loggedInUserModal.userId)
                avatar.updated_at = dateString
                
                kChatharedInstance.send_reply_comment(countDic: likecomment, commentDisc: comment, poster: poster, avtar: avatar, postId: String.getString(self.postid), replypostId: comment_id )
                
                self.commentTextfield.text = ""
                self.commentId = 0
                self.receiveComment()
                //self.tableView.reloadData()
                
            }
            
        }
        
    }
//    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
//        textField.resignFirstResponder()
//    }
    

    func getcurrentdateWithTime(datetime :String?) -> String {
        
        //initialize the Date Formatter
         let dateFormatter1 = DateFormatter()

         //specify the date Format
         dateFormatter1.dateFormat="yyyy-MM-dd HH:mm:ss"

         //get date from string
        let dateString = dateFormatter1.date(from: datetime!)

         //get timestamp from Date
        let dateTimeStamp  = dateString!.timeIntervalSince1970
        
        let date = Date(timeIntervalSince1970: dateTimeStamp)
        let dateFormatter = DateFormatter()
        dateFormatter.dateStyle = .short
        dateFormatter.timeZone = .current
        dateFormatter.dateFormat = "dd MM YYYY"
        dateFormatter.locale =  Locale(identifier:  "en")
        let localDate = dateFormatter.string(from: date)
        
        let units = Set<Calendar.Component>([.year, .month, .day, .hour, .minute, .second, .weekOfYear])
            let components = Calendar.current.dateComponents(units, from: date, to: Date())

            if components.year! > 0 {
                return "\(components.year!) " + (components.year! > 1 ? "years ago" : "year ago")

            } else if components.month! > 0 {
                return "\(components.month!) " + (components.month! > 1 ? "months ago" : "month ago")

            } else if components.weekOfYear! > 0 {
                return "\(components.weekOfYear!) " + (components.weekOfYear! > 1 ? "weeks ago" : "week ago")

            } else if (components.day! > 0) {
                return (components.day! > 1 ? "\(components.day!) Days" : "Yesterday")

            } else if components.hour! > 0 {
                return "\(components.hour!) " + (components.hour! > 1 ? "hours ago" : "hour ago")

            } else if components.minute! > 0 {
                return "\(components.minute!) " + (components.minute! > 1 ? "minutes ago" : "minute ago")

            } else {
                return "\(components.second!) " + (components.second! > 1 ? "seconds ago" : "second ago")
            }
        
    }

    func sendReply(_ commentID: Int) {
        guard let text = self.commentTextfield.text else {
            showAlert(withMessage: "Comment can't be blank.")
            return
        }

        let selfID = Int(kSharedUserDefaults.loggedInUserModal.userId ?? "-1") ?? 0
        let requestModel = PostComments.Reply.Request(post_owner_id: self.postCommentsUserDataModel.userID,
                                                     user_id: selfID,
                                                     post_id: self.postid,
                                                     comment_id: commentID,
                                                     comment: text)
        self.interactor?.postReply(requestModel)
    }

    // MARK:- IBAction methods
    @IBAction func backButtonTapped(_ sender: UIButtonExtended) {
        self.navigationController?.popViewController(animated: true)
    }

    @IBAction func profilePhotoButtonTapped(_ sender: UIButtonExtended) {

    }

    @IBAction func sendCommentButtonTapped(_ sender: UIButtonExtended) {
        if self.commentTextfield.text == "" {
            //self.sendReply(self.commentID)
            showAlert(withMessage: "Comment can't be blank.")
        } else {
            
            
            if self.commentId != 0 {
                self.sendReplyComment(comment_id: String.getString(self.commentId))
            } else if self.selectedcommentId != 0 && self.precommentId == 0{
                
                let params: [String:Any] = [
                    
                    "comment": self.commentTextfield.text ?? ""
                    
                ]
                
                TANetworkManager.sharedInstance.requestApi(withServiceName: APIUrl.kUpdateComment+"/"+String.getString(selectedcommentId), requestMethod: .POST, requestParameters: params, withProgressHUD: true) { (dictResponse, error, errorType, statusCode) in
                    
                    if statusCode == 200 {
                        kChatharedInstance.update_comment_message(msg: self.commentTextfield.text, postId: self.postid, commentId: self.selectedcommentId)
                        self.commentTextfield.text = ""
                        self.selectedcommentId = 0
                        self.view.endEditing(true)
                    }
                    
                }
                
                
            } else if self.precommentId != 0 {
                
                
                let params: [String:Any] = [
                    
                    "comment": self.commentTextfield.text ?? ""
                    
                ]
                
                TANetworkManager.sharedInstance.requestApi(withServiceName: APIUrl.kUpdateComment+"/"+String.getString(selectedcommentId), requestMethod: .POST, requestParameters: params, withProgressHUD: true) { (dictResponse, error, errorType, statusCode) in
                    
                    if statusCode == 200 {
                       
                        kChatharedInstance.update_replycomment_message(msg: self.commentTextfield.text, postId: self.postid, commentId: self.precommentId, replycommentId: self.selectedcommentId)
                        
                        self.commentTextfield.text = ""
                        self.selectedcommentId = 0
                        self.precommentId = 0
                        self.view.endEditing(true)
                    }
                    
                }
                
            } else {
                self.sendComment()
            }
            
            //self.commentTextfield.text = ""
        }
    }
    
    func callLikeUnlikeApi(_ isLike: Int?, _ postId: Int?, _ commentId: Int? ,_ indexPath: Int?){
        let selfID = Int(kSharedUserDefaults.loggedInUserModal.userId ?? "-1") ?? 0
        
        let params: [String:Any] = [
            "post_id": postId ?? 0,
            "like_or_unlike": isLike ?? 0,
            "user_id": selfID,
            "comment_id": commentId ?? 0
        ]
        TANetworkManager.sharedInstance.requestApi(withServiceName: APIUrl.kCommentLikeApi, requestMethod: .POST, requestParameters: params, withProgressHUD: true) { (dictResponse, error, errorType, statusCode) in
            
            if statusCode == 200 {
                
                let response = dictResponse as? [String:Any]
                let total_like = response?["total_likes"] as? Int
                let like_id = response?["like_id"] as? Int
                
                self.commentmessages?[indexPath ?? 0].comment_like_count = ((self.commentmessages?[indexPath ?? 0].comment_like_count ?? 0) + 1)
                
                if response?["message"] as! String == "You like this comment" {
                    
                    let likecomment = Comment_Like_Class()
                    likecomment.user_id = Int.getInt(kSharedUserDefaults.loggedInUserModal.userId)
                    likecomment.comment_id = commentId ?? 0
                    likecomment.like_id = like_id
                    
                    kChatharedInstance.send_comment_like(commentlike: likecomment, postid:  String.getString(postId))
                    
                } else {
                    //self.commentmessages?[indexPath ?? 0].isLike = false
                    kChatharedInstance.deleteParticularCommentLike(like_id: String.getString(like_id), post_id: String.getString(postId))
                }
                
                
                
                kChatharedInstance.update_comment_Like_count(likecount: total_like ?? 0, postId: postId ?? 0, commentId: commentId ?? 0)
            }
            
            
        }
    }

}

extension PostCommentsViewController: UITableViewDelegate, UITableViewDataSource {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return commentmessages?.count ?? 0
    }

    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        
        guard let cell = tableView.dequeueReusableCell(withIdentifier: "cell") as? SelfPostCommentsCell else {
            
            return UITableViewCell()
        }
        if self.commentmessages?.count ?? 0 > 0 {
            
            cell.commentReplyDelegate = self
            
            let data = self.commentmessages?[indexPath.row]
            if data?.isSelected == true {
                cell.setReply(self.commentmessages?[indexPath.row].reply ?? [], postid: String.getString(self.postid))
            } else {
                cell.setReply([], postid: "")
            }
            //cell.replyBtn.tag = indexPath.row
            cell.btnReplyCallback = {tag in
               // self.replyTap = true
                self.commentId = self.commentmessages?[indexPath.row].core_comment_id ?? 0
                self.commentTextfield.becomeFirstResponder()
                self.commentTextfield.placeholder = "Leave a Reply"
            }
            
            cell.btnLikeCallback = {tag in
                
                let commentid = self.commentmessages?[indexPath.row].core_comment_id ?? 0
                
                let like = self.commentmessages?[indexPath.row].isLike == false ? 1 : 0
                
                self.callLikeUnlikeApi(like, self.postid, commentid, indexPath.row)
                
            }
            
            cell.btnViewReplyCallback = {tag in
                
                if data?.isSelected == true {
                    data?.isSelected = false
                    cell.setReply([], postid: "")
                    self.tableView.reloadRows(at: [indexPath], with: .none)
                } else {
                    
                    data?.isSelected = true
                    cell.setReply(self.commentmessages?[indexPath.row].reply ?? [], postid: String.getString(self.postid))
                    self.tableView.reloadRows(at: [indexPath], with: .none)
                }
            }
            
            let selfID = Int(kSharedUserDefaults.loggedInUserModal.userId ?? "-1") ?? 0
            
            if self.commentmessages?[indexPath.row].data?.user_id == selfID {
                cell.threedotBtn.isHidden = false
                cell.threedotImg.isHidden = false
            } else {
                cell.threedotImg.isHidden = true
                cell.threedotBtn.isHidden = true
            }
            
            cell.replyEditCallback = {msg,previd,cmtid in
                
                self.commentTextfield.text = msg
                self.commentTextfield.becomeFirstResponder()
                self.selectedcommentId = cmtid
                self.precommentId = previd
            }
            
            cell.btnThreeDotCallback = {tag in
                
                let actionSheet = UIAlertController(style: .actionSheet)
                
                let edit = UIAlertAction(title: "Edit", style: .default) { action in
                    
                    self.commentTextfield.text = self.commentmessages?[indexPath.row].body
                    self.commentTextfield.becomeFirstResponder()
                    self.selectedcommentId = self.commentmessages?[indexPath.row].core_comment_id ?? 0
                    //
                    
                }
                
                let delete = UIAlertAction(title: "Delete", style: .destructive) { action in
                    
                    let postId = String.getString(self.postid)
                    let commentId = String.getString(self.commentmessages?[indexPath.row].core_comment_id)
                    
                    let params: [String:Any] = [
                        
                        "comment_id": self.commentmessages?[indexPath.row].core_comment_id ?? 0,
                        "post_id" : self.postid
                        
                    ]
                    
                    TANetworkManager.sharedInstance.requestApi(withServiceName: APIUrl.kDeleteComment, requestMethod: .POST, requestParameters: params, withProgressHUD: true) { (dictResponse, error, errorType, statusCode) in
                        
                        if statusCode == 200 {
                            kChatharedInstance.deleteParticularComment(post_id: postId, comment_id: commentId)
                        }
                        
                    }
                    
                }

                let cancelAction = UIAlertAction(title: "Cancel", style: .cancel) { action in

                }
                
                actionSheet.addAction(edit)
                actionSheet.addAction(delete)
                actionSheet.addAction(cancelAction)
                
                self.present(actionSheet, animated: true, completion: nil)

                
            }
            
            if self.commentmessages?[indexPath.row].reply.count ?? 0 > 0 {
                cell.viewReplyButtonconstraint.constant = 20
                cell.viewReplyButton.isHidden = false
                cell.viewReplyButton.setTitle("---- View \(self.commentmessages?[indexPath.row].reply.count ?? 0) Reply", for: .normal)
            } else {
                
                cell.viewReplyButtonconstraint.constant = 0
                cell.viewReplyButton.isHidden = true
            }
            
            let time = getcurrentdateWithTime(datetime: self.commentmessages?[indexPath.row].created_at)
            
            cell.likeimage.image = self.commentmessages?[indexPath.row].isLike == true ? UIImage(named: "liked_icon") : UIImage(named: "icons8_heart")
            
            cell.likecount.text = String.getString(self.commentmessages?[indexPath.row].comment_like_count)
            cell.descriptionLabel.text = self.commentmessages?[indexPath.row].body
            cell.userNameLabel.text = self.commentmessages?[indexPath.row].data?.restaurant_name//"\(name)"
            cell.timeLabel.text = "\(time)"
            cell.userImageView.setImage(withString:String.getString(self.commentmessages?[indexPath.row].data?.data?.attachment_url), placeholder: UIImage(named: "image_placeholder"))
            
        } else {
           // self.vwBlank.isHidden = false
        }
        return cell
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        print(self.commentmessages?[indexPath.row].body)
    }
    
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        
        return UITableView.automaticDimension
    }
}


extension PostCommentsViewController: CommnentReplyProtocol {
    func addReplyToComment(_ commentID: Int) {
        
        self.commentID = commentID
        self.commentTextfield.placeholder = "Add a reply to comment"
        self.commentTextfield.becomeFirstResponder()
    }

}

extension PostCommentsViewController: UITextFieldDelegate ,UITextViewDelegate{
    func textFieldDidEndEditing(_ textField: UITextField) {
        //self.commentTextfield.placeholder = "Leave a comment"
        self.commentId = 0
      
    }
    
    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
        textField.resignFirstResponder()
        return true
    }

// hides text views
func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
    if (text == "\n") {
        textView.text = textView.text + "\n"
//        textView.resignFirstResponder()
        return false
    }
    return true
}
// hides text fields
func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
    if (string == "\n") {
        textField.text = textField.text ?? "" + "\n"
//        textField.resignFirstResponder()
        return false
    }
    return true
}
}
extension String {
    func toImage() -> UIImage? {
        if let data = Data(base64Encoded: self, options: .ignoreUnknownCharacters){
            return UIImage(data: data)
        }
        return nil
    }
}
